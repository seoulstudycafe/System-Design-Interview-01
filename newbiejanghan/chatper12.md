# 12장. 채팅 시스템 설계
## 메시지 수신 시나리오
> 서버 -> 클라이언트로 연결이 생성되는 것처럼 보이게 하기

### 폴링(Polling)
- 클라이언트가 서버에게 주기적으로 요청을 보내는 방식
- 서버 자원에 불필요한 낭비

### 롱 폴링(Long Polling)
- 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지하는 방식
- HTTP의 stateless 와, 로드밸런싱을 고려하면 서버와 클라이언트가 동일한 채팅 서버에 연결되지 않을 수 있음.


### 웹소켓(WebSocket)
- 항구적, 양방향의 연결로, 처음 연결의 시작은 HTTP로 시작하지만 핸드셰이크 이후에는 웹소켓 프로토콜로 전환
- 항구적인 연결을 효율적으로 관리해야 함.

## 설계
- 로드 밸런서: 클라이언트에게 적합한 채팅 서버를 검색하고 전달해주기
- 무상태 서비스: 메인 API 서버
- 상태 유지 서비스: 채팅 서비스
- 푸시 알림 서비스

### DB
- 일반적 유저 데이터 => RDBMS의 replication, sharding을 활용하여 가용성, 규모확장성 확보
- 채팅 이력: 읽기 / 쓰기 패턴을 고려해야 함
    - 일반적으로 최근 메세지를 자주 읽는다.
    - 검색, 멘션된 메세지로 이동 등 최신 순이 아닌 무작위적인 데이터 접근도 가능해야 함
    - 1:1 채팅의 경우 읽기/쓰기 비율은 대략 1:1
- key value store: 채팅 이력을 저장하는데 적합
  - 수평적 확장이 가능하고, 빠른 읽기/쓰기 속도를 제공
  - RDBMS 는 **long tail** 에 해당하는 부분을 잘 처리하지 못함. 

### 서비스 탐색
- 클라이언트의 지리적 위치, 서버의 용량을 고려하여 적합한 채팅 서버로 연결해주는 것
- ex) Apache Zookeeper

## 메시지 흐름
### 1:1 채팅
- A => ID 생성기 => 채팅 서버 1 => 메시지 동기화 큐 => Key value store => 채팅 서버 2 / 푸시 알림 서버 => 사용자 B
- ID 생성기: 분산 시스템에서 고유한 메시지 ID를 생성
- Key value store: 메시지 저장. 동기화 큐에서 수시잔로 나갈 때 저장하기

### 여러 단말기 간 동기화
- 세션 확인
- cur_max_message_id: 단말기에서 관측된 가장 최신 메시지 ID

### 소규모 그룹 채팅방
- 소규모이기 때문에 수신자마다 동기화 큐를 갖는 방식이 적합하다.

### 접속상태 표시
- 접속 상태는 로그인, 로그아웃 시 timestamp 를 저장하는 방식이 기본적인 해결 방식이다.
- 임시적인 웹소켓 커넥션 해제 상태 마다 offline 으로 상태를 변경하기 보다는 heart beat 방식을 활용하는 것이 좋다.
  - 클라이언트가 x초 이내에 박동 이벤트를 반복적으로 보낸다면 이를 online 으로 여기는 것이다.
  - 만약 5초마다 박동 이벤트를 3번 연속 보낸 후 30초 간 메시지가 없다면 offlien 으로 처리할 수 있다.
- 상태 정보 서버는 pub-sub 모델을 채택할 수 있다. 이는 앞서 언급한 '소규모 그룹 채팅방'과 마찬가지로 제한 인원이 적을 때 효과적이다.